#version 440 core

layout (isolines, equal_spacing, ccw) in;

struct MVP
{
    mat4 Model;
    mat4 View;
    mat4 Projection;
};

uniform MVP u_MVP;

///////////////////////////////////////////////////
// function to evaluate  the Bezier curve
vec4 bezier(float u, vec4[4] array)
{
    //Wyznaczneie stopnia wielomianu
    int size = 3;
    for (;array[size].w == 0.0f && size > 0; --size);

    //algorytm de castaljeu
    for (int h = 0; h < size; ++h)
    for (int i = 0; i < size - h;  i++)
    array[i] = (1.0f - u) * array[i] + u * array[i + 1];

    return vec4(array[0].xyz, 1.0f);
}

vec3 deboor(float t, inout vec3 P10, inout vec3 P20, inout vec3 P30, inout vec3 P40) {
    const float u = 2.f + t;

    const float a41 = (u - 2.0f) / 3.0f;
    const float a31 = (u - 1.0f) / 3.0f;
    const float a21 = (u) / 3.0f;

    const float b41 = 1.0f - a41;
    const float b31 = 1.0f - a31;
    const float b21 = 1.0f - a21;

    const vec3 P41 = a41 * P40 + b41 * P30;
    const vec3 P31 = a31 * P30 + b31 * P20;
    const vec3 P21 = a21 * P20 + b21 * P10;

    const float a42 = (u - 2.0f) / 2.0f;
    const float a32 = (u - 1.0f) / 2.0f;

    const float b42 = 1.0f - a42;
    const float b32 = 1.0f - a32;

    const vec3 P42 = a42 * P41 + b42 * P31;
    const vec3 P32 = a32 * P31 + b32 * P21;

    const float a43 = (u - 2.0f) / 1.0f;
    const float b43 = 1.0f - a43;

    const vec3 P43 = a43 * P42 + b43 * P32;

    return P43;
}

void
main()
{
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    vec4 bernsteinPoints[4];

    bernsteinPoints[0] = 1.0f / 6.0f * gl_in[0].gl_Position + 2.0f / 3.0f * gl_in[1].gl_Position + 1.0f / 6.0f * gl_in[2].gl_Position;
    bernsteinPoints[1] = 2.0f / 3.0f * gl_in[1].gl_Position + 1.0f / 3.0f * gl_in[2].gl_Position;
    bernsteinPoints[2] = 1.0f / 3.0f * gl_in[1].gl_Position + 2.0f / 3.0f * gl_in[2].gl_Position;
    bernsteinPoints[3] = 1.0f / 6.0f * gl_in[1].gl_Position + 2.0f / 3.0f * gl_in[2].gl_Position + 1.0f / 6.0f * gl_in[3].gl_Position;
    vec4 pos = bezier(u, bernsteinPoints);

    gl_Position = u_MVP.Projection * u_MVP.View * u_MVP.Model * pos;
}