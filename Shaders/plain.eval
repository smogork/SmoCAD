#version 440 core

layout (quads, equal_spacing, ccw) in;

struct MVP
{
    mat4 Model;
    mat4 View;
    mat4 Projection;
};

uniform MVP u_MVP;

///////////////////////////////////////////////////
// function to evaluate  the Bezier curve
vec4 bezier(float t, vec4[4] array)
{
    //Wyznaczneie stopnia wielomianu
    int size = 3;
    //for (;array[size].w == 0.0f && size > 0; --size);

    //algorytm de castaljeu
    for (int h = 0; h < size; ++h)
    for (int i = 0; i < size - h;  i++)
    array[i] = (1.0f - t) * array[i] + t * array[i + 1];

    return vec4(array[0].xyz, 1.0f);
}

void loadBezierData(int idx, vec4[4] outArray)
{
    for (int i = 0; i < 4; ++i)
        outArray[i] = gl_in[idx + i].gl_Position;
}

void
main()
{
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    vec4 midValue[4];
    vec4 bezierData[4];

    int idx = 0;
    for (int i = 0; i < 4; ++i)
        bezierData[i] = gl_in[idx + i].gl_Position;
    midValue[0] = bezier(u, bezierData);

    idx = 4;
    for (int i = 0; i < 4; ++i)
        bezierData[i] = gl_in[idx + i].gl_Position;
    midValue[1] = bezier(u, bezierData);

    idx = 8;
    for (int i = 0; i < 4; ++i)
        bezierData[i] = gl_in[idx + i].gl_Position;
    midValue[2] = bezier(u, bezierData);

    idx = 12;
    for (int i = 0; i < 4; ++i)
        bezierData[i] = gl_in[idx + i].gl_Position;
    midValue[3] = bezier(u, bezierData);

    vec4 pos = bezier(v, midValue);
    gl_Position = u_MVP.Projection * u_MVP.View * u_MVP.Model * pos;
}
